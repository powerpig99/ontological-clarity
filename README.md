# Ontological Clarity

A framework for achieving clarity on any topic by tracing it to ontological foundations. One line generates everything.

> *Everything is layered projections of the infinite-dimensional orthogonal binary hyperspace from Nothing—the infinitely self-referencing Contradiction.*

This was arrived at by tracing everything to its ultimate root. Not built or designed—its compressibility is a discovered property of the structure itself.

## What This Is

A method for cutting through narratives, dissolving false dichotomies, and exposing mechanism where moral framing obscures it. The core move: trace projections as-is, identify where collapse creates confusion, dissolve the collapse. This applies at every scale. The projections differ. The method is the same.

The framework used to be 5,000+ lines across multiple files. Everything was derivable from the one line above. So everything derived was removed. What remains in `SKILL.md` is the generative ground: 139 lines connecting the principle to practical application across any domain. Every analysis is traced fresh. The tracing is the practice, not the product.

## Context Engine

The same methodology applied to any long-form context. See [context-engine](https://github.com/powerpig99/context-engine).

The framework's condensation—5,000 lines to one generative line with increased clarity—demonstrated something: any accumulated context can be traced to its generative ground, and from that ground, relevant derivations regenerate on demand with more clarity than the original.

The [Context Engine](https://github.com/powerpig99/context-engine) does this for any long-form context: a document, a codebase, a conversation, a corpus. Between any generative ground and any question, there is a bridging context—the derivation path connecting them. The bridge grows when understanding grows, not when words accumulate. It consolidates across domains toward the principle.

### Prior Work

[Dialectical-TTS](https://github.com/powerpig99/Dialectical-TTS) and [Recursive Dialectical Engine](https://github.com/powerpig99/recursive-dialectical-engine) (both archived) were iterative explorations that discovered: multiple independent collapses composed through necessity outperform single-pass inference, and cross-model diversity produces genuinely different collapses. Both were traced to ground and rebuilt as the Context Engine. Their test infrastructure remains useful.

## How to Use

### As a Thinking Tool

Read `SKILL.md`. Apply the three-step method. If the analysis produces a named pattern, use it once and let it go. The pattern will re-emerge wherever the mechanism operates. If it doesn't re-emerge without the name, the name was doing the work the analysis should have been doing.

### With AI Systems

`SKILL.md` is a single markdown file—designed to work as a knowledge file, system prompt, or skill in any agentic application.

- **Claude Projects**: Add `SKILL.md` to a project's knowledge.
- **Claude Code**: Place as a skill under `~/.claude/skills/` or `.claude/skills/`. See [`claude-code-setup/`](claude-code-setup/) for the full bridge methodology.
- **Other systems**: Any application that accepts instructions can ingest `SKILL.md` directly. Self-contained, no dependencies.

## Structure

```
├── SKILL.md                    # The framework. 139 lines. The ground.
├── README.md                   # You are here.
└── claude-code-setup/          # Setting up Claude Code with the bridge methodology.
    └── GUIDE.md                # User memory, project memory, session loop.
```

## Epistemological Stance

Evidence, not proof. The framework has been applied across domains—AI architecture, education, political discourse, ontological analysis—and in each case produced more clarifying results than prior framings. It should work better than methods that operate further from the generative ground, because every other method is derivative from the same structure. "Should" and "has" are not "must" and "always will." Held provisionally. This framework is itself a projection.

## Evolution

The framework improves through application, not accumulation. The self-check: can you trace the mechanism fresh without referencing the skill's vocabulary? If not, the vocabulary is doing the work the analysis should be doing. When the skill fails this check, it gets condensed again.

We can always start over.

## License

[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)
